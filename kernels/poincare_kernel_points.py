import sys
sys.path.append('/data/lige/HKN')# Please change accordingly!

import torch
import matplotlib.pyplot as plt
from os import makedirs
from os.path import join, exists

from manifolds.poincare import PoincareBall
from manifolds.base import ManifoldParameter 
from optim import RiemannianAdam, RiemannianSGD

seed = 12345
torch.manual_seed(seed)

class simple_PoincareWrappedNormal(torch.nn.Module):
    """
    1. Note: ToBn=Rn
    2. scale controls the "spreadout" of points relative to origin
    """
    def __init__(self, loc, scale, manifold, c):
        super(simple_PoincareWrappedNormal, self).__init__()
        self.loc = loc
        self.scale = scale
        self.manifold = manifold
        self.c = c

    def sample(self, shape):
        tangent_samples = torch.randn(*shape, self.loc.shape[-1], dtype=self.c.dtype) * self.scale
        tangent_samples = tangent_samples.to(self.c.device)
        projected_samples = self.manifold.expmap0(tangent_samples, self.c)
        projected_samples = ManifoldParameter(projected_samples, manifold=self.manifold, requires_grad=True, c=self.c)
        return self.manifold.proj(projected_samples, c=self.c)

def get_origin_kernel_points_poincare(num_kernel, dim, manifold, c, max_iter=10000, verbose=False):
    kernel_points = simple_PoincareWrappedNormal(
        loc=manifold.origin(dim, c=c), #origin is on the same device as c
        scale=1, #c is a tensor while scare is a number
        manifold=manifold, 
        c=c #this function is used in load_kernel func, which c is from the encoder, so on cuda if used
    ).sample([num_kernel - 1])

    # Track the gradient computation of those points
    kernel_points = ManifoldParameter(kernel_points, manifold=manifold, requires_grad=True, c=c)
    
    fix_point = manifold.origin(dim, c=c)
    origin = manifold.origin(dim, c=c)

    lr = 1e-4
    alpha = 1  # 1
    beta = 10  # 10

    optimizer = RiemannianSGD([kernel_points], lr=lr)

    for t in range(max_iter):
        optimizer.zero_grad()
        loss = 0
        for i in range(num_kernel - 1):
            # This is because 1 kernel point must be the origin!!!
            loss += alpha * (1 / manifold.sqdist(fix_point, kernel_points[i], c=c))
            for j in range(i + 1, num_kernel - 1):
                loss += alpha * (1 / manifold.sqdist(kernel_points[i], kernel_points[j], c=c))
                # Potential between pairs of kernel points
            loss += beta * manifold.sqdist(origin, kernel_points[i], c=c)
            # Potential between origin and kernel points
        
        loss.backward(retain_graph=True)
        if t % 500 == 0 and verbose:
            print(f'epoch {t}, loss: {loss.item()}')
        optimizer.step()
        # Projection to ensure the points remain within the Poincare disk
        # THIS STEP IS DAMN CRUCIAL!!!!!!!!!!!!!
        with torch.no_grad():
            kernel_points.data = manifold.proj(kernel_points, c=c)

    return torch.cat([fix_point.view(1, dim), kernel_points.detach()])

def load_kernels(manifold, radius, num_kpoints, dimension, c, random=False):
    """
    Note: it returns the projection of kernel points on tangent space of origin
    Random==True:
    Directly return kernel points as points generated by wrapped normal distribution
    Random==False:
    Return kernel points as points calculated by optimization
    """
    if random:
        kernel_points = simple_PoincareWrappedNormal(
            loc=manifold.origin(dimension, c=c), 
            scale=1, 
            manifold=manifold, 
            c=c
        ).sample([num_kpoints - 1])
        fix_point = manifold.origin(dimension, c=c)
        kernel_points = torch.cat([fix_point.view(1, dimension), kernel_points.detach()])
        kernel_tangents = manifold.logmap0(kernel_points, c=c)
        
        origin = manifold.origin(dimension, c=c)
        dis = torch.sqrt(manifold.sqdist(kernel_points, origin, c=c).max())
        
        kernel_tangents *= radius / dis
        return kernel_tangents
    
    # Kernel directory
    kernel_dir = './kernels/dispositions'
    if not exists(kernel_dir):
        makedirs(kernel_dir)

    # Kernel file
    kernel_file = join(kernel_dir, f'poincare_k_{num_kpoints:03d}_{dimension}D.pt')

    # Check if already done
    if not exists(kernel_file):
        kernel_points = get_origin_kernel_points_poincare(num_kpoints, dimension, manifold, c, max_iter=6000, verbose=False)
        kernel_tangents = manifold.logmap0(kernel_points[1:], c)#I think kernel_points should be on the same device with c, cause this line didn't throw error
        kernel_tangents = torch.cat([torch.zeros(1, dimension, dtype=kernel_tangents.dtype, device=kernel_tangents.device), kernel_tangents])
        torch.save(kernel_tangents, kernel_file)
    else:
        kernel_tangents = torch.load(kernel_file) #Kernel tangents are loaded to cpu first
        #print(kernel_tangents.device,c.device)
        kernel_tangents = kernel_tangents.to(c.device)
        kernel_points = manifold.expmap0(kernel_tangents, c)

    # Scale kernels
    origin = manifold.origin(dimension, c=c)
    dis = torch.sqrt(manifold.sqdist(kernel_points, origin, c=c).max())
    kernel_tangents *= radius / dis

    return kernel_tangents

def plot_points_on_poincare_ball(points, filename):
    fig, ax = plt.subplots()
    ax.set_aspect('equal')

    # Draw Poincare disk
    circle = plt.Circle((0, 0), 1, color='r', fill=False)
    ax.add_artist(circle)

    # Plot points
    ax.scatter(points[:, 0], points[:, 1])

    # Set limits and show plot
    ax.set_xlim(-1.1, 1.1)
    ax.set_ylim(-1.1, 1.1)
    plt.grid(True)

    # Save plot as PDF
    plt.savefig(filename, format='pdf')
    plt.close()

# A toy example
if __name__ == "__main__":
    manifold = PoincareBall()
    radius =1
    num_kpoints = 7
    dimension = 2
    c = 1

    kernel_tangents = load_kernels(manifold, radius, num_kpoints, dimension, random=False, c=c)
    kernel_points = manifold.expmap0(kernel_tangents, c=c)
    print(kernel_points)

    # Define filename
    kernel_dir = './kernels/dispositions'
    if not exists(kernel_dir):
        makedirs(kernel_dir)
    filename = join(kernel_dir, f'fig_k_{num_kpoints:03d}_{dimension}D.pdf')

    # Plot and save points
    test3 = kernel_points
    plot_points_on_poincare_ball(test3.detach().numpy(), filename)
